import { exec } from "child_process";
import { promisify } from "util";
import { writeFile, readFile } from "fs/promises";
import { marked } from "marked";
import puppeteer from "puppeteer";
import { Artifact, Project } from "../drizzle/schema";
import { storagePut } from "./storage";

const execAsync = promisify(exec);

/**
 * Export artifact to Markdown format
 */
export async function exportToMarkdown(artifact: Artifact, project: Project): Promise<string> {
  const content = artifact.generatedContent || artifact.content || 'No content available';
  
  const markdown = `# ${artifact.name}

**Project:** ${project.name}  
**Phase:** ${artifact.phase}  
**Type:** ${artifact.type}  
**Status:** ${artifact.status}  
**Created:** ${new Date(artifact.createdAt).toLocaleDateString()}  
**Updated:** ${new Date(artifact.updatedAt).toLocaleDateString()}

---

## Description

${project.description || 'No project description'}

---

## Content

${content}

---

*Generated by TOGAF Artifact Generator*  
*TOGAF 10 Architecture Development Method*
`;

  return markdown;
}

/**
 * Export artifact to PDF format
 */
export async function exportToPDF(artifact: Artifact, project: Project | null): Promise<string> {
  if (!project) throw new Error('Project not found');
  
  try {
    console.log('[exportToPDF] Starting PDF generation for artifact:', artifact.id);
    
    // First generate markdown
    const markdown = await exportToMarkdown(artifact, project);
  
  // Save markdown to temp file
  const tempMdPath = `/tmp/artifact-${artifact.id}-${Date.now()}.md`;
  const tempPdfPath = `/tmp/artifact-${artifact.id}-${Date.now()}.pdf`;
  
  await writeFile(tempMdPath, markdown);
  
  // Convert markdown to HTML
  const html = marked(markdown);
  
  // Generate PDF using puppeteer
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  try {
    const page = await browser.newPage();
    await page.setContent(`
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="UTF-8">
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; padding: 40px; }
            h1 { color: #333; border-bottom: 2px solid #333; padding-bottom: 10px; }
            h2 { color: #555; margin-top: 30px; }
            h3 { color: #777; }
            table { border-collapse: collapse; width: 100%; margin: 20px 0; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f2f2f2; }
          </style>
        </head>
        <body>${html}</body>
      </html>
    `, { waitUntil: 'networkidle0' });
    
    await page.pdf({
      path: tempPdfPath,
      format: 'A4',
      margin: { top: '20mm', right: '20mm', bottom: '20mm', left: '20mm' },
      printBackground: true
    });
  } finally {
    await browser.close();
  }
  
  console.log('[exportToPDF] PDF generated successfully, uploading to S3');
  
  // Upload to S3
  const pdfBuffer = await readFile(tempPdfPath);
  const fileName = `${artifact.name.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
  const { url } = await storagePut(
    `exports/${project.id}/${fileName}`,
    pdfBuffer,
    'application/pdf'
  );
  
  // Clean up temp files
  await execAsync(`rm ${tempMdPath} ${tempPdfPath}`);
  
  console.log('[exportToPDF] Upload complete, URL:', url);
  return url;
  } catch (error) {
    console.error('[exportToPDF] Error:', error);
    throw error;
  }
}

/**
 * Export artifact to Word format (DOCX)
 */
export async function exportToWord(artifact: Artifact, project: Project): Promise<string> {
  // First generate markdown
  const markdown = await exportToMarkdown(artifact, project);
  
  // Save markdown to temp file
  const tempMdPath = `/tmp/artifact-${artifact.id}-${Date.now()}.md`;
  const tempDocxPath = `/tmp/artifact-${artifact.id}-${Date.now()}.docx`;
  
  await writeFile(tempMdPath, markdown);
  
  // Convert to DOCX using pandoc (need to install)
  try {
    await execAsync(`pandoc ${tempMdPath} -o ${tempDocxPath}`);
  } catch (error) {
    // If pandoc not available, fall back to PDF
    console.warn('Pandoc not available, falling back to PDF export');
    return await exportToPDF(artifact, project);
  }
  
  // Upload to S3
  const docxBuffer = await readFile(tempDocxPath);
  const fileName = `${artifact.name.replace(/[^a-zA-Z0-9]/g, '_')}.docx`;
  const { url } = await storagePut(
    `exports/${project.id}/${fileName}`,
    docxBuffer,
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  );
  
  // Clean up temp files
  await execAsync(`rm ${tempMdPath} ${tempDocxPath}`);
  
  return url;
}

/**
 * Export multiple artifacts as a bundled deliverable
 */
export async function exportDeliverable(
  artifacts: Artifact[],
  project: Project,
  format: 'markdown' | 'pdf' | 'word'
): Promise<string> {
  // Combine all artifacts into one document
  const combinedContent = artifacts.map((artifact) => {
    const content = artifact.generatedContent || artifact.content || 'No content available';
    return `# ${artifact.name}

**Phase:** ${artifact.phase}  
**Type:** ${artifact.type}  
**Status:** ${artifact.status}

---

${content}

---

`;
  }).join('\n\n');

  const markdown = `# ${project.name} - TOGAF Deliverable

**Project Description:** ${project.description || 'No description'}  
**Current Phase:** ${project.currentPhase}  
**Status:** ${project.status}  
**Generated:** ${new Date().toLocaleDateString()}

---

## Table of Contents

${artifacts.map((a, idx) => `${idx + 1}. ${a.name} (${a.phase})`).join('\n')}

---

${combinedContent}

---

*Generated by TOGAF Artifact Generator*  
*TOGAF 10 Architecture Development Method*
`;

  if (format === 'markdown') {
    const fileName = `${project.name.replace(/[^a-zA-Z0-9]/g, '_')}_Deliverable.md`;
    const { url } = await storagePut(
      `exports/${project.id}/${fileName}`,
      Buffer.from(markdown),
      'text/markdown'
    );
    return url;
  }

  // Save markdown to temp file
  const tempMdPath = `/tmp/deliverable-${project.id}-${Date.now()}.md`;
  await writeFile(tempMdPath, markdown);

  if (format === 'pdf') {
    const tempPdfPath = `/tmp/deliverable-${project.id}-${Date.now()}.pdf`;
    
    // Convert markdown to HTML
    const html = marked(markdown);
    
    // Generate PDF using puppeteer
    const browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    try {
      const page = await browser.newPage();
      await page.setContent(`
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="UTF-8">
            <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; padding: 40px; }
              h1 { color: #333; border-bottom: 2px solid #333; padding-bottom: 10px; }
              h2 { color: #555; margin-top: 30px; }
              h3 { color: #777; }
              table { border-collapse: collapse; width: 100%; margin: 20px 0; }
              th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
              th { background-color: #f2f2f2; }
            </style>
          </head>
          <body>${html}</body>
        </html>
      `, { waitUntil: 'networkidle0' });
      
      await page.pdf({
        path: tempPdfPath,
        format: 'A4',
        margin: { top: '20mm', right: '20mm', bottom: '20mm', left: '20mm' },
        printBackground: true
      });
    } finally {
      await browser.close();
    }
    
    const pdfBuffer = await readFile(tempPdfPath);
    const fileName = `${project.name.replace(/[^a-zA-Z0-9]/g, '_')}_Deliverable.pdf`;
    const { url } = await storagePut(
      `exports/${project.id}/${fileName}`,
      pdfBuffer,
      'application/pdf'
    );
    
    await execAsync(`rm ${tempMdPath} ${tempPdfPath}`);
    return url;
  }

  if (format === 'word') {
    const tempDocxPath = `/tmp/deliverable-${project.id}-${Date.now()}.docx`;
    
    try {
      await execAsync(`pandoc ${tempMdPath} -o ${tempDocxPath}`);
      
      const docxBuffer = await readFile(tempDocxPath);
      const fileName = `${project.name.replace(/[^a-zA-Z0-9]/g, '_')}_Deliverable.docx`;
      const { url } = await storagePut(
        `exports/${project.id}/${fileName}`,
        docxBuffer,
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      );
      
      await execAsync(`rm ${tempMdPath} ${tempDocxPath}`);
      return url;
    } catch (error) {
      // Fallback to PDF
      console.warn('Pandoc not available, falling back to PDF');
      await execAsync(`rm ${tempMdPath}`);
      
      const tempPdfPath = `/tmp/deliverable-${project.id}-${Date.now()}.pdf`;
      await writeFile(tempMdPath, markdown);
      
      // Convert markdown to HTML
      const html = marked(markdown);
      
      // Generate PDF using puppeteer
      const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      try {
        const page = await browser.newPage();
        await page.setContent(`
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="UTF-8">
              <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; padding: 40px; }
                h1 { color: #333; border-bottom: 2px solid #333; padding-bottom: 10px; }
                h2 { color: #555; margin-top: 30px; }
                h3 { color: #777; }
                table { border-collapse: collapse; width: 100%; margin: 20px 0; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #f2f2f2; }
              </style>
            </head>
            <body>${html}</body>
          </html>
        `, { waitUntil: 'networkidle0' });
        
        await page.pdf({
          path: tempPdfPath,
          format: 'A4',
          margin: { top: '20mm', right: '20mm', bottom: '20mm', left: '20mm' },
          printBackground: true
        });
      } finally {
        await browser.close();
      }
      
      const pdfBuffer = await readFile(tempPdfPath);
      const fileName = `${project.name.replace(/[^a-zA-Z0-9]/g, '_')}_Deliverable.pdf`;
      const { url } = await storagePut(
        `exports/${project.id}/${fileName}`,
        pdfBuffer,
        'application/pdf'
      );
      
      await execAsync(`rm ${tempMdPath} ${tempPdfPath}`);
      return url;
    }
  }

  throw new Error(`Unsupported format: ${format}`);
}

/**
 * Export artifact with all related content (questionnaire, assumptions, etc.)
 */
export async function exportArtifactComplete(
  artifact: Artifact,
  project: Project,
  questionnaire: any[],
  assumptions: any[]
): Promise<string> {
  const content = artifact.generatedContent || artifact.content || 'No content available';
  
  const questionnaireSection = questionnaire.length > 0 ? `
## Questionnaire Responses

${questionnaire.map(q => `**${q.questionText}**\n\n${q.answer || 'No answer provided'}\n`).join('\n')}
` : '';

  const assumptionsSection = assumptions.length > 0 ? `
## Assumptions

${assumptions.map((a, idx) => `
### ${idx + 1}. ${a.description}

**Rationale:** ${a.rationale || 'Not specified'}  
**Impact:** ${a.impact}  
**Status:** ${a.isValidated ? '✓ Validated' : '○ Not validated'}
`).join('\n')}
` : '';

  const markdown = `# ${artifact.name}

**Project:** ${project.name}  
**Phase:** ${artifact.phase}  
**Type:** ${artifact.type}  
**Status:** ${artifact.status}  
**Created:** ${new Date(artifact.createdAt).toLocaleDateString()}  
**Updated:** ${new Date(artifact.updatedAt).toLocaleDateString()}

---

## Project Context

${project.description || 'No project description'}

---

${questionnaireSection}

---

## Artifact Content

${content}

---

${assumptionsSection}

---

*Generated by TOGAF Artifact Generator*  
*TOGAF 10 Architecture Development Method*
`;

  return markdown;
}
